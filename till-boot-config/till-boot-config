#!/usr/bin/env python3

import sys
import os
import argparse
import yaml
from pathlib import Path
import shutil
import socket
import logging

log = logging.getLogger("till-boot-config")

def path_or_fail(path, desc):
    if not path:
        log.critical("%s not specified", desc)
        sys.exit(1)
    return Path(path)

def path_or_none(path):
    return Path(path) if path else None

def run():
    parser = argparse.ArgumentParser("Set up networked boot for quicktill")
    parser.add_argument("--config-file", "-c", help="config file location",
                        default="/etc/till-boot/config")
    parser.add_argument("--nfs-dir", help="override nfs root location")
    parser.add_argument("--tftp-dir", help="override tftp dir location")
    parser.add_argument("--boot-dir",
                        help="override kernel+initrd dir location")
    parser.add_argument("--loaders-dir", help="override loaders loction")
    parser.add_argument("--http-dir", help="override http dir location")
    parser.add_argument("--verbose", "-v", help="output more information "
                        "about operation", action="store_true")
    args = parser.parse_args()

    if args.verbose:
        loglevel = logging.INFO
    else:
        loglevel = logging.WARNING

    logging.basicConfig(level=loglevel)
    
    # Read the configuration
    with open(args.config_file) as f:
        config = yaml.safe_load(f)

    nfs_dir = path_or_fail(args.nfs_dir or config["nfs-dir"], "nfs-dir")
    tftp_dir = path_or_fail(args.tftp_dir or config["tftp-dir"], "tftp-dir")
    boot_dir = path_or_fail(args.boot_dir or config["boot-dir"], "boot-dir")
    http_dir = path_or_none(args.http_dir or config.get("http-dir", None))
    http_server = config.get("http-server", [])
    loaders_dir = path_or_none(args.loaders_dir or config.get(
        "loaders-dir", None))
    if not loaders_dir:
        loaders_dir = nfs_dir / 'loaders'

    default_append = config.get("default-append", [])

    defaults = config.get("defaults", {})

    # Initial checks: nfs_dir and tftp_dir should exist and be directories
    if not nfs_dir.is_dir():
        log.critical("nfs root dir %s doesn't exist", nfs_dir)
        sys.exit(1)
    if not tftp_dir.is_dir():
        log.critical("tftp dir %s doesn't exist", tftp_dir)
        sys.exit(1)

    if not nfs_dir.is_absolute():
        log.warning("nfs dir %s is relative", nfs_dir)
    if not tftp_dir.is_absolute():
        log.warning("tftp dir %s is relative", tftp_dir)

    if not boot_dir.is_dir():
        log.critical("boot files directory %s doesn't exist", boot_dir)
        sys.exit(1)

    # If http_dir is specified it should exist and be a directory,
    # and http_server must be specified
    if http_dir:
        if not http_dir.is_dir():
            log.critical("http dir %s doesn't exist", http_dir)
            sys.exit(1)
        if not http_dir.is_absolute():
            log.warning("http dir %s is relative", http_dir)
        if not http_server:
            log.critical("http-dir is specified, but http-server is not")
            sys.exit(1)
        if http_server[-1] != '/':
            http_server = http_server + '/'

    # Make sure the loaders are copied into the tftp dir
    if not loaders_dir.is_dir():
        log.critical("loaders dir %s doesn't exist", loaders_dir)
        sys.exit(1)
    loaders = loaders_dir.glob("*")
    for l in loaders:
        dest = tftp_dir / l.name
        if dest.exists():
            dest.unlink()
        # Passing a PathLike to shutil and os.path functions doesn't
        # work until python3.6 - unfortunately Ubuntu 16.04 only has
        # python3.5.
        shutil.copyfile(str(l), str(dest))

    # Build a catalog of till boot files available on this machine
    # (dist, arch, version) => boot files installed?
    catalog = {}
    distributions = nfs_dir.glob("*")
    for dist_dir in distributions:
        if dist_dir == loaders_dir:
            continue
        if not dist_dir.is_dir():
            continue
        for arch_dir in dist_dir.glob("*"):
            if not arch_dir.is_dir():
                continue
            for version_dir in arch_dir.glob("*"):
                if not version_dir.is_dir():
                    continue
                # Check that the casper/till.squashfs file exists
                squashfs = version_dir / "casper" / "till.squashfs"
                if not squashfs.is_file():
                    continue
                dist = dist_dir.name
                arch = arch_dir.name
                version = version_dir.name
                bpath = boot_dir / dist / arch / version
                # Check that the kernel and initrd files exist
                if not (bpath / "vmlinuz").is_file():
                    continue
                if not (bpath / "initrd.img").is_file():
                    continue
                # Add to the catalog
                log.info("available: %s %s %s", dist, arch, version)
                catalog[(dist, arch, version)] = False

    # Build a dictionary of (distribution, arch) -> latest version
    latest = {}
    for dist, arch, version in catalog.keys():
        if version > latest.get((dist, arch), ""):
            latest[(dist, arch)] = version

    # Process the configuration for each till
    for till, till_settings in config.get("tills", {}).items():
        settings = defaults.copy()
        settings.update(till_settings)

        cf = tftp_dir / "{}.ipxe".format(till)
        distribution = settings.get("distribution")
        arch = settings.get("architecture")
        version = settings.get("version")
        if isinstance(version, int):
            version = str(version)
        if not distribution or not arch or not version:
            log.error("till %s: incomplete specification of dist/arch/version",
                      till)
            continue
        if version == "latest":
            version = latest.get((distribution, arch))
        if (distribution, arch, version) not in catalog:
            log.error("till %s: requested dist/arch/version not available",
                      till)
            print((distribution, arch, version))
            continue

        if version == latest[(distribution, arch)]:
            kfile = "vmlinuz-{}-{}".format(distribution, arch)
            ifile = "initrd-{}-{}.img".format(distribution, arch)
        else:
            kfile = "vmlinuz-{}-{}-{}".format(distribution, arch, version)
            ifile = "initrd-{}-{}-{}.img".format(distribution, arch, version)

        # Update the settings with the actual version selected
        settings["version"] = version

        # Copy the kernel and initrd into place if this has not
        # already been done
        if not catalog[(distribution, arch, version)]:
            kernel_src = boot_dir / distribution / arch / version / "vmlinuz"
            kernel_dest = tftp_dir / kfile
            shutil.copyfile(str(kernel_src), str(kernel_dest))
            initrd_src = boot_dir / distribution / arch / version / "initrd.img"
            initrd_dest = tftp_dir / ifile
            shutil.copyfile(str(initrd_src), str(initrd_dest))
            catalog[(distribution, arch, version)] = True

        nfs_root_dir = nfs_dir / distribution / arch / version
        append = [
            "initrd={}".format(ifile),
            "netboot=nfs",
            "nfsroot={}:{}".format(config["nfs-server"], nfs_root_dir),
            "boot=casper",
        ]
        http_config_append = [
            "till-boot-version={}".format(version),
            "till-boot-config={}{}.yaml".format(http_server, till),
        ]
        if http_dir:
            append += http_config_append
        append += default_append
        append += settings.get("append", [])
        # Shorthand for append of configname in older till-boot configurations
        # with no http-based run-time config
        if not http_dir and "configname" in settings:
            append.append("configname={}".format(settings["configname"]))

        # From python3.6 onward this can be written open(cf, 'w')
        with cf.open('w') as f:
            f.write("#!ipxe\n")
            f.write("# This file was auto-generated by {} for {}; "
                    "do not edit\n\n".format(sys.argv[0], till))
            f.write("echo Booting {}\n".format(till))
            f.write("kernel {} {} || chain ipxe.pxe\n".format(
                kfile, " ".join(append)))
            f.write("initrd {}\n".format(ifile))
            f.write("boot\n")

        if http_dir:
            hf = http_dir / "{}.yaml".format(till)
            with hf.open('w') as f:
                f.write("%YAML 1.1\n")
                f.write("---\n")
                f.write("# This file was auto-generated by {} for {}; "
                         "do not edit\n".format(sys.argv[0], till))
                yaml.dump(settings, f)

if __name__ == "__main__":
    run()
