#!/usr/bin/env python3

import sys
import os
import argparse
import yaml
from pathlib import Path
import shutil
import socket
import logging

log = logging.getLogger("till-boot-setup")

def run():
    parser = argparse.ArgumentParser("Set up networked boot for quicktill")
    parser.add_argument("--config-file", "-c", help="config file location",
                        default="/etc/till-boot/config")
    parser.add_argument("--nfs-dir", help="override nfs root location")
    parser.add_argument("--tftp-dir", help="override tftp dir location")
    parser.add_argument("--boot-dir",
                        help="override kernel+initrd dir location")
    parser.add_argument("--loaders-dir", help="override loaders loction")
    parser.add_argument("--verbose", "-v", help="output more information "
                        "about operation", action="store_true")
    args = parser.parse_args()

    if args.verbose:
        loglevel = logging.INFO
    else:
        loglevel = logging.WARNING

    logging.basicConfig(level=loglevel)
    
    # Read the configuration
    with open(args.config_file) as f:
        config = yaml.load(f)

    nfs_dir = Path(args.nfs_dir or config["nfs-dir"])
    tftp_dir = Path(args.tftp_dir or config["tftp-dir"])
    boot_dir = Path(args.boot_dir or config["boot-dir"])
    loaders_dir = nfs_dir / 'loaders'
    if args.loaders_dir:
        ald = Path(args.loaders_dir)
        if ald.is_absolute():
            loaders_dir = ald
        else:
            loaders_dir = loaders_dir / ald
    config_dir = tftp_dir

    default_append = config.get("default-append", [])

    defaults = config.get("defaults", {})

    # Initial checks: nfs_dir and tftp_dir should exist and be directories
    if not nfs_dir.is_dir():
        log.critical("nfs root dir %s doesn't exist", nfs_dir)
        sys.exit(1)
    if not tftp_dir.is_dir():
        log.critical("tftp dir %s doesn't exist", tftp_dir)
        sys.exit(1)

    if not nfs_dir.is_absolute():
        log.warning("nfs dir %s is relative", nfs_dir)
    if not tftp_dir.is_absolute():
        log.warning("tftp dir %s is relative", tftp_dir)

    if not boot_dir.is_dir():
        log.critical("boot files directory %s doesn't exist", boot_dir)
        sys.exit(1)

    # Create the config dir if it doesn't exist
    config_dir.mkdir(mode=0o755, exist_ok=True)

    # Make sure the loaders are copied into the tftp dir
    if not loaders_dir.is_dir():
        log.critical("loaders dir %s doesn't exist", loaders_dir)
        sys.exit(1)
    loaders = loaders_dir.glob("*")
    for l in loaders:
        dest = tftp_dir / l.name
        if dest.exists():
            dest.unlink()
        # Passing a PathLike to shutil and os.path functions doesn't
        # work until python3.6 - unfortunately Ubuntu 16.04 only has
        # python3.5.
        shutil.copyfile(str(l), str(dest))

    # Build a catalog of till boot files available on this machine
    # (dist, arch, version) => boot files installed?
    catalog = {}
    distributions = nfs_dir.glob("*")
    for dist_dir in distributions:
        if dist_dir == loaders_dir:
            continue
        if not dist_dir.is_dir():
            continue
        for arch_dir in dist_dir.glob("*"):
            if not arch_dir.is_dir():
                continue
            for version_dir in arch_dir.glob("*"):
                if not version_dir.is_dir():
                    continue
                # Check that the casper/till.squashfs file exists
                squashfs = version_dir / "casper" / "till.squashfs"
                if not squashfs.is_file():
                    continue
                dist = dist_dir.name
                arch = arch_dir.name
                version = version_dir.name
                bpath = boot_dir / dist / arch / version
                # Check that the kernel and initrd files exist
                if not (bpath / "vmlinuz").is_file():
                    continue
                if not (bpath / "initrd.img").is_file():
                    continue
                # Add to the catalog
                log.info("available: %s %s %s", dist, arch, version)
                catalog[(dist, arch, version)] = False

    # Build a dictionary of (distribution, arch) -> latest version
    latest = {}
    for dist, arch, version in catalog.keys():
        if version > latest.get((dist, arch), ""):
            latest[(dist, arch)] = version

    # Process the configuration for each till
    for till, till_settings in config.get("tills", {}).items():
        settings = defaults.copy()
        settings.update(till_settings)

        cf = config_dir / "{}.ipxe".format(till)
        distribution = settings.get("distribution")
        arch = settings.get("architecture")
        version = settings.get("version")
        if isinstance(version, int):
            version = str(version)
        if not distribution or not arch or not version:
            log.error("till %s: incomplete specification of dist/arch/version",
                      till)
            continue
        if version == "latest":
            version = latest.get((distribution, arch))
        if (distribution, arch, version) not in catalog:
            log.error("till %s: requested dist/arch/version not available",
                      till)
            print((distribution, arch, version))
            continue

        if version == latest[(distribution, arch)]:
            kfile = "vmlinuz-{}-{}".format(distribution, arch)
            ifile = "initrd-{}-{}.img".format(distribution, arch)
        else:
            kfile = "vmlinuz-{}-{}-{}".format(distribution, arch, version)
            ifile = "initrd-{}-{}-{}.img".format(distribution, arch, version)

        # Copy the kernel and initrd into place if this has not
        # already been done
        if not catalog[(distribution, arch, version)]:
            kernel_src = boot_dir / distribution / arch / version / "vmlinuz"
            kernel_dest = tftp_dir / kfile
            shutil.copyfile(str(kernel_src), str(kernel_dest))
            initrd_src = boot_dir / distribution / arch / version / "initrd.img"
            initrd_dest = tftp_dir / ifile
            shutil.copyfile(str(initrd_src), str(initrd_dest))
            catalog[(distribution, arch, version)] = True

        nfs_root_dir = nfs_dir / distribution / arch / version
        append = [
            "initrd={}".format(ifile),
            "netboot=nfs",
            "nfsroot={}:{}".format(config["nfs-server"], nfs_root_dir),
            "boot=casper"
        ]
        append += default_append
        append += settings.get("append", [])
        # Shorthand, because I keep getting it wrong!
        if "configname" in settings:
            append.append("configname={}".format(settings["configname"]))

        # From python3.6 onward this can be written open(cf, 'w')
        with cf.open('w') as f:
            f.write("#!ipxe\n")
            f.write("# This file was auto-generated by {} for {}; "
                    "do not edit\n\n".format(sys.argv[0], till))
            f.write("echo Booting {}\n".format(till))
            f.write("kernel {} {} || chain ipxe.pxe\n".format(
                kfile, " ".join(append)))
            f.write("initrd {}\n".format(ifile))
            #f.write("imgstat\n")
            #f.write("sleep 10\n")
            f.write("boot\n")

if __name__ == "__main__":
    run()
