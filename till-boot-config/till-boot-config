#!/usr/bin/env python3

import sys
import os
import argparse
import json
import io
from pathlib import Path
import os.path
import shutil
import logging
from logging import Logger
import datetime
import ipaddress
from collections import ChainMap
from typing import Tuple, List, Dict, Set
from typing import NoReturn, Any, Optional, Iterable, Type
import jinja2

try:
    import tomllib
except ModuleNotFoundError:
    import tomli as tomllib  # type: ignore[no-redef]

log = logging.getLogger("till-boot-config")


template_environment = jinja2.Environment()

network_template = template_environment.from_string("""{# -#}
# This file was autogenerated by {{script_name}}
# Do not edit manually!
[Match]
Name={{interface}}

[Link]
RequiredForOnline=yes
ActivationPolicy=always-up

[Network]
Description=Tills network
DHCP=no
Address={{ipv4_interface}}
{% if upstream_interface -%}
IPForward=ipv4
{% endif -%}
IPv6AcceptRA=false
LinkLocalAddressing=no
ConfigureWithoutCarrier=yes
IgnoreCarrierLoss=yes

""")

nftables_template = template_environment.from_string("""#!/usr/sbin/nft -f
# This file was autogenerated by {{script_name}}
# Do not edit manually!

flush ruleset

# Combined IPv4 and IPv6
table inet filter {
    chain input {
        type filter hook input priority filter; policy drop;
        ct state invalid drop
        ct state {established, related} accept
        # Drop connections to loopback not coming from loopback
        iif != lo ip daddr 127.0.0.1/8 drop
        # Accept loopback
        iif lo accept
        # Accept these on all interfaces
        ip protocol icmp accept
        meta l4proto ipv6-icmp accept
        tcp dport { 22, 80, 443 } accept
        {%- if firewall_accept %}
        # Additional firewall accept rules from config file
        {%- for rule in firewall_accept %}
        tcp dport {{rule.port}} ip saddr {{rule.network}} accept
        {%- endfor -%}
        {%- endif %}
        # Accept everything from the tills network
        iif {{interface}} accept
        # Reject everything else politely
        reject with icmp type admin-prohibited
    }
{% if upstream_interface %}
    chain forward {
        type filter hook forward priority filter; policy drop;
        # Only forward from/to the tills network
        ip saddr {{ipv4_network}} accept
        ip daddr {{ipv4_network}} accept
    }
{% endif %}
    chain output {
        type filter hook output priority filter; policy accept;
    }
}
{% if upstream_interface -%}
# IPv4 NAT for tills network
# outputting to the network on {{upstream_interface}}
table nat {
    chain prerouting {
        type nat hook prerouting priority filter; policy accept;
    }

    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;
        ip saddr {{ipv4_network}} oifname "{{upstream_interface}}" masquerade
    }
}
{% endif -%}
""")

ipxe_template = template_environment.from_string("""#!ipxe
# This file was auto-generated by {{script_name}} for {{till}}; do not edit

echo Booting {{till}}
kernel {{kfile}} {{' '.join(append)}} || chain ipxe.pxe
initrd {{ifile}}
boot

""")

init_ipxe_template = template_environment.from_string("""#!ipxe
# This file was auto-generated by {{script_name}}; do not edit

echo Fetching ipxe configuration for ${hostname}...
chain ${hostname}.ipxe

""")


def fail() -> NoReturn:
    sys.exit(1)


def dirpath_or_fail(log: Logger, config: Dict[str, Any], name: str) -> Path:
    pathname = config.get(name, None)
    if not pathname:
        log.critical("%s not specified", name)
        fail()
    path = Path(pathname)
    if not path.exists():
        log.critical("%s (%s) does not exist", name, path)
        fail()
    if not path.is_dir():
        log.critical("%s is not a directory", name)
        fail()
    if not path.is_absolute():
        log.warning("%s (%s) is relative", name, path)
    return path


def path_or_none(path: Optional[str]) -> Optional[Path]:
    return Path(path) if path else None


class FileOperation:
    def apply(self, log: Logger, dry_run: bool) -> None:
        pass


class DelTree(FileOperation):
    def __init__(self, path: Path):
        self.path = path

    def apply(self, log: Logger, dry_run: bool) -> None:
        if dry_run:
            log.info("would rmtree %s", self.path)
        else:
            shutil.rmtree(self.path, ignore_errors=True)

    def __str__(self) -> str:
        return f"rmtree({self.path})"


class UnlinkFileIfExists(FileOperation):
    def __init__(self, path: Path):
        self.path = path

    def apply(self, log: Logger, dry_run: bool) -> None:
        if dry_run:
            log.info("would unlink %s if it exists", self.path)
        else:
            if self.path.exists():
                self.path.unlink()

    def __str__(self) -> str:
        return f"unlink_file_if_exists({self.path})"


class CopyTree(FileOperation):
    def __init__(self, src: Path, dest: Path):
        self.src = src
        self.dest = dest

    def apply(self, log: Logger, dry_run: bool) -> None:
        if dry_run:
            log.info("would copytree %s to %s", self.src, self.dest)
        else:
            shutil.copytree(self.src, self.dest)

    def __str__(self) -> str:
        return f"copytree({self.src}, {self.dest})"


class CopyFile(FileOperation):
    def __init__(self, src: Path, dest: Path):
        self.src = src
        self.dest = dest

    def apply(self, log: Logger, dry_run: bool) -> None:
        if dry_run:
            log.info("would copy file %s to %s", self.src, self.dest)
        else:
            shutil.copyfile(self.src, self.dest)

    def __str__(self) -> str:
        return f"copyfile({self.src}, {self.dest})"


class WriteJsonFile(FileOperation):
    def __init__(self, contents: Dict[str, Any], dest: Path):
        self.contents = contents
        self.dest = dest

    def apply(self, log: Logger, dry_run: bool) -> None:
        if dry_run:
            log.info("would write json to file %s", self.dest)
        else:
            with self.dest.open('w') as f:
                json.dump(self.contents, f, indent=2)

    def __str__(self) -> str:
        return f"write_json({self.dest})"


class WriteTemplateFile(FileOperation):
    def __init__(self, template: jinja2.Template, ctx: Dict[str, Any],
                 dest: Path):
        self.template = template
        self.ctx = ctx
        self.dest = dest

    def apply(self, log: Logger, dry_run: bool) -> None:
        if dry_run:
            log.info("would write template to file %s", self.dest)
        else:
            with self.dest.open('w') as f:
                f.write(self.template.render(self.ctx))

    def __str__(self) -> str:
        return f"write_template({self.dest})"


class WriteFile(FileOperation):
    def __init__(self, contents: str, dest: Path):
        self.contents = contents
        self.dest = dest

    def apply(self, log: Logger, dry_run: bool) -> None:
        if dry_run:
            log.info("would write file %s", self.dest)
        else:
            with self.dest.open('w') as f:
                f.write(self.contents)

    def __str__(self) -> str:
        return f"write({self.dest})"


class Host:
    """A configured host, set up by a driver
    """
    def __init__(self, name: str, settings: Dict[str, Any]):
        self.log = log.getChild(name)
        self.name = name
        self.settings = settings
        self.fileops: List[FileOperation] = []

        # This reservation will be updated with IPv4 address and other
        # settings later
        self.kea_reservation = {
            "hw-address": self.settings.get('mac'),
            "hostname": self.name,
        }

    def add_fileops(self, fileops: Iterable[FileOperation]) -> None:
        self.fileops.extend(fileops)

    def apply_fileops(self, dry_run: bool) -> None:
        for op in self.fileops:
            op.apply(self.log, dry_run)


class _driver:
    drivers: Dict[str, Type["_driver"]] = {}

    def __init_subclass__(cls) -> None:
        cls.drivers[getattr(cls, "driver_name", cls.__name__)] = cls

    def __init__(self, name: str, config: Dict[str, Any]):
        self.name = name
        self.log = log.getChild(name)

    def configure(self, name: str, settings: ChainMap[str, Any]) -> Host:
        if "mac" not in settings:
            self.log.warning(
                "till %s: no 'mac' setting specified; this will become "
                "a required setting in the future", name)

        return Host(name, dict(settings))

    def fileops(self) -> Iterable[FileOperation]:
        # A list of file operations needed by the driver, independently
        # of any hosts
        return []


class generic(_driver):
    pass


class till_boot(_driver):
    driver_name = "till-boot"

    def __init__(self, name: str, config: Dict[str, Any]):
        super().__init__(name, config)
        self.nfs_dir = dirpath_or_fail(self.log, config, "nfs-dir")
        self.tftp_dir = dirpath_or_fail(self.log, config, "tftp-dir")
        self.boot_dir = dirpath_or_fail(self.log, config, "boot-dir")
        self.http_dir = dirpath_or_fail(self.log, config, "http-dir")
        self.loaders_dir = path_or_none(config.get("loaders-dir"))

        # Do we actually need any bootloaders? On a system with rpi
        # 4+5 clients only, we don't!
        self.loaders: List[Path] = []
        if not self.loaders_dir:
            self.loaders_dir = self.nfs_dir / 'loaders'
        if self.loaders_dir.is_dir():
            self.loaders = list(self.loaders_dir.glob("*"))
        else:
            self.log.warning("loaders dir %s doesn't exist", self.loaders_dir)

        self.default_append = config.get("default-append", [])

        # Not currently used, but will be used in the future to generate a
        # dhcpd config file fragment
        self.tftp_server = config.get("tftp-server")
        if not self.tftp_server:
            self.log.critical("tftp-server is not specified")
            fail()

        self.http_server = config.get("http-server")
        if not self.http_server:
            self.log.critical("http-server is not specified")
            fail()
        if self.http_server[-1] != '/':
            self.http_server = self.http_server + '/'

        self.nfs_server = config.get("nfs-server")
        if not self.nfs_server:
            self.log.critical("nfs-server is not specified")
            fail()

        # Find and store the platform defaults
        self.platform_defaults = {
            platform: config.get(f"defaults-{platform}", {})
            for platform in _platform.platforms}

        # Build a catalog of till boot files available on this machine
        # (platform, arch, version) => platform class instance
        self.catalog = {}
        platform_dirs = self.nfs_dir.glob("*")
        for platform_dir in platform_dirs:
            if platform_dir == self.loaders_dir:
                continue
            if not platform_dir.is_dir():
                continue
            if platform_dir.name not in _platform.platforms:
                self.log.warning("unknown platform %s in nfs dir",
                                 platform_dir.name)
                continue
            for arch_dir in platform_dir.glob("*"):
                if not arch_dir.is_dir():
                    continue
                for version_dir in arch_dir.glob("*"):
                    if not version_dir.is_dir():
                        continue
                    platform = platform_dir.name
                    arch = arch_dir.name
                    version = version_dir.name
                    bpath = self.boot_dir / platform / arch / version
                    # Check that the image info file exists
                    info_file = version_dir / "image-info.json"
                    if not info_file.is_file():
                        self.log.warning("%s is not a file", info_file)
                        continue
                    # Parse the info file
                    with open(info_file) as f:
                        info = json.load(f)
                        # Check that platform and arch match
                    if info.get('platform') != platform:
                        self.log.warning(
                            "platform in info file %s does not match path",
                            info_file)
                        continue
                    if info.get('architecture') != arch:
                        self.log.warning(
                            "arch in info file %s does not match path",
                            info_file)
                        continue
                    platform_class = _platform.platforms.get(platform)
                    if not platform_class:
                        self.log.warning("unsupported platform %s", platform)
                        continue
                    image = platform_class(
                        self.log, info, version, version_dir, bpath,
                        self.nfs_server, self.http_server)
                    # Check the boot files are ok for the platform
                    if not image.boot_files_ok():
                        self.log.warning("missing boot files for %s", image)
                        continue
                    # Add to the catalog
                    self.log.info(
                        "available: %s %s %s", platform, arch, version)
                    self.catalog[(platform, arch, version)] = image

        # Build a dictionary of (platform, arch) -> latest version
        self.latest: Dict[Tuple[str, str], str] = {}
        for platform, arch, version in self.catalog.keys():
            if version > self.latest.get((platform, arch), ""):
                self.latest[(platform, arch)] = version

    def configure(self, name: str, settings: ChainMap[str, Any]) -> Host:
        platform = settings.get("platform")
        if not platform:
            self.log.critical("till %s: no platform specified", name)
            fail()

        if platform not in self.platform_defaults:
            self.log.critical("till %s: platform %s does not exist",
                              name, platform)
            fail()

        # settings is currently a ChainMap of till_settings, roles, defaults

        # We want name, till_settings, roles, platform defaults, defaults
        settings.maps.insert(-1, self.platform_defaults[platform])
        settings.maps.insert(0, {'name': name})

        arch = settings.get("architecture")
        version = settings.get("version")
        if isinstance(version, int):
            version = str(version)
            settings["version"] = version
        if not arch or not version:
            self.log.critical(
                "till %s: incomplete specification of arch/version",
                name)
            fail()
        using_latest = False
        if version == "latest":
            version = self.latest.get((platform, arch))
            if not version:
                self.log.critical(
                    "till %s: requested platform/arch %s not available",
                    name, (platform, arch))
                fail()
            using_latest = True
            settings["version"] = version

        image = self.catalog.get((platform, arch, version))

        if not image:
            self.log.critical(
                "till %s: requested platform/arch/version %s "
                "not available", name, (platform, arch, version))
            fail()

        # Flattened settings
        fset = dict(settings)

        missing_setting = image.check_settings(fset)
        if missing_setting:
            self.log.critical("till %s: %s missing", name, missing_setting)
            fail()

        host = super().configure(name, settings)
        host.add_fileops(image.install(
            self.tftp_dir, self.http_dir, fset, using_latest,
            self.default_append))

        host.add_fileops([
            WriteJsonFile(fset, self.http_dir / f"{name}.json")])

        image.apply_network_settings(fset, host)

        return host

    def fileops(self) -> Iterable[FileOperation]:
        # Make sure the loaders are copied into the tftp dir
        for loader in self.loaders:
            dest = self.tftp_dir / loader.name
            yield UnlinkFileIfExists(dest)
            yield CopyFile(loader, dest)
        # Create the "init.ipxe" script
        yield WriteTemplateFile(init_ipxe_template, {
            'script_name': sys.argv[0]}, self.tftp_dir / "init.ipxe")


class _platform:
    description = "generic platform"
    required_settings = [
        "name",  # inserted automatically
    ]

    platforms: Dict[str, Type["_platform"]] = {}

    def __init__(self, log: Logger, info: Dict[str, Any], version: str,
                 mount_path: Path, boot_path: Path,
                 nfs_server: str, http_server: str):
        self.log = log.getChild(
            f"{info['platform']}-{info['architecture']}-{version}")
        self.info = info
        self.version = version
        self.mount_path = mount_path
        self.boot_path = boot_path
        self.architecture = info['architecture']
        self.nfs_server = nfs_server
        self.http_server = http_server

    def __init_subclass__(cls) -> None:
        cls.platforms[cls.__name__] = cls

    def boot_files_ok(self) -> bool:
        return True

    def get_append(self, settings: Dict[str, Any]) -> List[str]:
        append = list(self.info['append'])
        append += [
            "netboot=nfs",
            f"nfsroot={self.nfs_server}:{self.mount_path}",
            f"till-boot-version={self.version}",
            f"till-boot-config-json={self.http_server}{settings['name']}.json",
        ]
        return append

    def check_settings(self, settings: Dict[str, Any]) -> Optional[str]:
        for s in self.required_settings:
            if s not in settings:
                return s
        return None

    def install(self, tftp_dir: Path, http_dir: Path,
                settings: Dict[str, Any], latest: bool,
                default_append: List[str]) -> Iterable[FileOperation]:
        yield from []
        self.log.critical("unexpected generic install!")
        fail()

    def apply_network_settings(self, settings: Dict[str, Any],
                               host: Host) -> None:
        pass

    def __str__(self) -> str:
        return f"{self.description}: {self.architecture} {self.version}"


class pc(_platform):
    description = "PC"

    def __init__(self, log: Logger, info: Dict[str, Any], version: str,
                 mount_path: Path, boot_path: Path,
                 nfs_server: str, http_server: str):
        super().__init__(log, info, version, mount_path, boot_path,
                         nfs_server, http_server)
        self.kernel = None
        self.initrd = None
        # Find our kernel and initrd files
        bpath = self.boot_path / "boot"
        possible_kernels = list(bpath.glob("vmlinuz-*"))
        if len(possible_kernels) == 1:
            self.kernel = possible_kernels[0]
        else:
            log.warning("%s: possible_kernels %s", self, possible_kernels)
        possible_initrds = list(bpath.glob("initrd.img-*"))
        if len(possible_initrds) == 1:
            self.initrd = possible_initrds[0]
        else:
            log.warning("%s: possible_initrds %s", self, possible_initrds)
        self.installed = False

    def boot_files_ok(self) -> bool:
        if not self.kernel or not self.kernel.is_file():
            self.log.warning("%s: missing kernel", self)
            return False
        if not self.initrd or not self.initrd.is_file():
            self.log.warning("%s: missing initrd", self)
            return False
        return True

    def install(self, tftp_dir: Path, http_dir: Path,
                settings: Dict[str, Any], latest: bool,
                default_append: List[str]) -> Iterable[FileOperation]:
        till = settings['name']

        if not self.kernel or not self.initrd:
            self.log.critical("missing kernel or initrd at install time")
            fail()

        if latest:
            kfile = f"vmlinuz-pc-{self.architecture}"
            ifile = f"initrd-pc-{self.architecture}.img"
        else:
            kfile = f"vmlinuz-pc-{self.architecture}-{self.version}"
            ifile = f"initrd-pc-{self.architecture}-{self.version}.img"

        # Copy the kernel and initrd into place if this has not
        # already been done
        if not self.installed:
            yield CopyFile(self.kernel, http_dir / kfile)
            yield CopyFile(self.initrd, http_dir / ifile)
            self.installed = True

        append = self.get_append(settings)
        # Including the initrd filename on the kernel command line is
        # necessary for EFI systems and harmless on others.
        append.append(f"initrd={ifile}")
        append += default_append
        append += settings.get("append", [])

        yield WriteTemplateFile(
            ipxe_template, {
                'script_name': sys.argv[0],
                'till': till,
                'kfile': kfile,
                'ifile': ifile,
                'append': append,
            }, tftp_dir / f"{till}.ipxe")


class rpi(_platform):
    description = "Raspberry PI"
    required_boot_files = [
        "bootcode.bin",
        "start.elf",
        "fixup.dat",
        "start4.elf",
        "fixup4.dat",
        "start4x.elf",
        "fixup4x.dat",
    ]

    # initrd suffixes used prior to bookworm
    initrd_suffixes = {
        'kernel.img': '+',
        'kernel7.img': '-v7+',
        'kernel7l.img': '-v7l+',
        'kernel8.img': '-v8+',
    }

    # initrd names used from bookworm onwards
    initrd_names = {
        'kernel.img': 'initramfs',
        'kernel7.img': 'initramfs7',
        'kernel7l.img': 'initramfs7l',
        'kernel8.img': 'initramfs8',
        'kernel_2712.img': 'initramfs_2712',
    }

    armhf_kernels = {
        'pi0': 'kernel.img',
        'pi1': 'kernel.img',
        'pi2': 'kernel7.img',
        'pi3': 'kernel7.img',
        'pi4': 'kernel7l.img',
    }

    required_settings = _platform.required_settings + ["serial"]

    def __init__(self, log: Logger, info: Dict[str, Any], version: str,
                 mount_path: Path, boot_path: Path,
                 nfs_server: str, http_server: str):
        super().__init__(log, info, version, mount_path, boot_path,
                         nfs_server, http_server)
        self.bpath = self.boot_path / "boot"
        self.initrds: Dict[str, Path] = {}  # kernel name -> initrd path
        self.pre_bookworm = False

        # As of the "bookworm" release there is a new scheme for /boot
        # on Raspberries; /boot itself is on the root filesystem and
        # /boot/firmware is the VFAT partition on the boot device.

        fpath = self.bpath / "firmware"
        if fpath.is_dir():
            self.bpath = fpath
            self._init_bookworm()
        else:
            self._init_pre_bookworm()

    def _init_pre_bookworm(self) -> None:
        self.pre_bookworm = True
        possible_initrds = list(self.bpath.glob("initrd.img-*"))
        prefix = os.path.commonprefix([x.name for x in possible_initrds])
        for kernel_name, suffix in self.initrd_suffixes.items():
            kernel = self.bpath / kernel_name
            if not kernel.is_file():
                continue
            initrd = None
            for i in possible_initrds:
                if not i.is_file():
                    continue
                if i.name[len(prefix):] == suffix:
                    initrd = i
                    break
            if initrd:
                self.initrds[kernel_name] = initrd

    def _init_bookworm(self) -> None:
        for kernel_name, initrd_name in self.initrd_names.items():
            kernel = self.bpath / kernel_name
            if not kernel.is_file():
                continue
            initrd = self.bpath / initrd_name
            if not initrd.is_file():
                continue
            self.initrds[kernel_name] = initrd

    def get_append(self, settings: Dict[str, Any]) -> List[str]:
        append = super().get_append(settings)
        if 'ntp-server' in settings:
            append.append(f"ntp-server={settings['ntp-server']}")
        return append

    def boot_files_ok(self) -> bool:
        for f in self.required_boot_files:
            path = self.bpath / f
            if not path.is_file():
                return False
        if self.architecture == "armhf":
            for k in ("kernel.img", "kernel7.img", "kernel7l.img"):
                if k not in self.initrds:
                    return False
        elif self.architecture == "arm64":
            if "kernel8.img" not in self.initrds:
                return False
        return True

    def install(self, tftp_dir: Path, http_dir: Path,
                settings: Dict[str, Any], latest: bool,
                default_append: List[str]) -> Iterable[FileOperation]:
        till = settings['name']

        if 'ntp-server' not in settings:
            log.warning("%s: ntp-server not specified, time will "
                        "not be set in initrd", till)

        serial = settings['serial']
        serial_dir = tftp_dir / serial

        override_firmware = path_or_none(settings.get("override-firmware"))

        # Copy the firmware and kernel into place
        yield DelTree(serial_dir)
        if override_firmware:
            yield CopyTree(override_firmware, serial_dir)
            # Use the kernels and initrds from the image
            for kernel, initrd in self.initrds.items():
                yield CopyFile(self.bpath / kernel, serial_dir)
                yield CopyFile(initrd, serial_dir)
        else:
            yield CopyTree(self.bpath, serial_dir)

        # Kernel command line
        append = self.get_append(settings)
        append += default_append
        append += settings.get("append", [])
        cmdline_file = serial_dir / "cmdline.txt"
        yield WriteFile(f"{' '.join(append)}\n", cmdline_file)

        # Config file
        config_file = serial_dir / "config.txt"
        with io.StringIO() as f:
            f.write(f"# This file was auto-generated by {sys.argv[0]} "
                    f"for {till}; do not edit\n")
            f.write(f"# Generated {datetime.datetime.now()}\n\n")

            if self.pre_bookworm:
                if self.architecture == 'armhf':
                    for model, kernel in self.armhf_kernels.items():
                        f.write(f"[{model}]\n")
                        f.write(f"initramfs {self.initrds[kernel].name} "
                                f"followkernel\n\n")
                if self.architecture == 'arm64':
                    f.write("arm_64bit=1\n")
                    f.write(f"initramfs {self.initrds['kernel8.img'].name} "
                            f"followkernel\n\n")
            for model in self.armhf_kernels.keys():
                mcfg = self.info.get(f"config-{model}", []) \
                    + settings.get(f"config-{model}", [])
                if mcfg:
                    f.write(f"[{model}]\n")
                    for ci in mcfg:
                        f.write(f"{ci}\n")
                    f.write("\n")
            f.write("[all]\n")
            for ci in self.info.get("config", []) + settings.get("config", []):
                f.write(f"{ci}\n")
            f.write("\n# end\n\n")
            yield WriteFile(f.getvalue(), config_file)

    def apply_network_settings(self, settings: Dict[str, Any],
                               host: Host) -> None:
        host.kea_reservation["client-classes"] = ["rpi-pxe"]


class Network:
    def __init__(self, config: Dict[str, Any]):
        # Initially we're just going to support one network instance;
        # we may raise this limit in the future if more complicated
        # network topologies seem useful
        self.log = log.getChild("network")

        self.interface = config.get("interface")
        if not self.interface:
            self.log.critical("interface name must be specified")
            fail()

        self.upstream_interface = config.get("upstream-interface")

        if "ipv4" not in config:
            self.log.critical("ipv4 network must be specified")
            fail()

        try:
            interface = ipaddress.IPv4Interface(config['ipv4'])
        except ValueError as e:
            self.log.critical("ipv4: %s", e)
            fail()

        self.network_file = path_or_none(config.get("network-file"))
        self.nftables_file = path_or_none(config.get("nftables-file"))
        self.kea_dhcp4_file = path_or_none(config.get("kea-dhcp4-file"))

        self.firewall_accept = config.get("firewall-accept", [])
        for rule in self.firewall_accept:
            if "port" not in rule:
                self.log.critical("firewall-accept: rule missing port")
                fail()
            if "network" not in rule:
                self.log.critical("firewall-accept: rule missing network")
                fail()

        self.ipv4_interface = interface
        self.ipv4_address = interface.ip
        self.ipv4_network = interface.network

        self.ipv4_claimed: Set[ipaddress.IPv4Address] = set()
        self.claim_ipv4(self.ipv4_address)

        self._ipv4_iter = self.ipv4_network.hosts()

    def claim_ipv4(self, address: ipaddress.IPv4Address) -> None:
        if not isinstance(address, ipaddress.IPv4Address):
            self.log.critical("address %s is not an IPv4Address")
            fail()
        if address not in self.ipv4_network:
            self.log.critical("address %s not in tills network", address)
            fail()
        if address in self.ipv4_claimed:
            self.log.critical("address %s already claimed", address)
            fail()
        self.ipv4_claimed.add(address)

    def _allocate_ipv4(self) -> ipaddress.IPv4Address:
        try:
            while True:
                i = next(self._ipv4_iter)
                if i not in self.ipv4_claimed:
                    self.ipv4_claimed.add(i)
                    return i
        except StopIteration:
            self.log.critical("no more ipv4 addresses left in tills network")
            fail()

    def allocate_addresses(self, tills: List[Host]) -> None:
        for till in tills:
            if "ipv4" in till.settings:
                try:
                    ipv4_address = ipaddress.IPv4Address(till.settings['ipv4'])
                except ValueError as e:
                    self.log.critical("%s: ipv4: %s", till.name, e)
                    fail()
                self.claim_ipv4(ipv4_address)
        for till in tills:
            if "ipv4" not in till.settings:
                ipv4_address = self._allocate_ipv4()
            till.kea_reservation["ip-address"] = str(ipv4_address)

    def kea_dhcp4_config(self, tills: List[Host]) -> Dict[str, Any]:
        till_reservations = [
            till.kea_reservation for till in tills if "mac" in till.settings]

        dhcp4 = {
            "interfaces-config": {
                "interfaces": [self.interface],
            },
            "control-socket": {
                "socket-type": "unix",
                "socket-name": "/run/kea/kea4-ctrl-socket",
            },
            "lease-database": {
                "type": "memfile",
                "lfc-interval": 3600,
            },
            "expired-leases-processing": {
                "reclaim-timer-wait-time": 10,
                "flush-reclaimed-timer-wait-time": 25,
                "hold-reclaimed-time": 3600,
                "max-reclaim-leases": 100,
                "max-reclaim-time": 250,
                "unwarned-reclaim-cycles": 5,
            },
            "renew-timer": 900,
            "rebind-timer": 1800,
            "valid-lifetime": 3600,
            "option-def": [
                # {
                #     "name": "PXEDiscoveryControl",
                #     "code": 6,
                #     "space": "vendor-encapsulated-options-space",
                #     "type": "uint8",
                #     "array": False,
                # },
                # {
                #     "name": "PXEMenuPrompt",
                #     "code": 10,
                #     "space": "vendor-encapsulated-options-space",
                #     "type": "record",
                #     "array": False,
                #     "record-types": "uint8,string",
                # },
                {
                    "name": "PXEBootMenu",
                    "code": 9,
                    "space": "vendor-encapsulated-options-space",
                    "type": "record",
                    "array": False,
                    "record-types": "uint16,uint8,string",
                },
            ],
            "option-data": [
                {
                    "name": "domain-name-servers",
                    "data": str(self.ipv4_address),
                },
            ],
            "client-classes": [
                {
                    "name": "ipxe",
                    "test": "option[77].hex == 'iPXE'",
                    "boot-file-name": "init.ipxe",
                },
                {
                    "name": "pxe-legacy",
                    "test": "not member('ipxe') and option[93].hex == 0x0000",
                    "boot-file-name": "ipxe.pxe",
                },
                {
                    "name": "pxe-uefi",
                    "test": "not member('ipxe') and not member('pxe-legacy')",
                    "boot-file-name": "ipxe.efi",
                },
                {
                    "name": "rpi-pxe",
                    "boot-file-name": "bootcode.bin",
                    "option-data": [
                        # {
                        #     "name": "boot-file-name",
                        #     "data": "bootcode.bin",
                        # },
                        {
                            "name": "vendor-class-identifier",
                            "data": "PXEClient",
                        },
                        {
                            "name": "vendor-encapsulated-options",
                        },
                        {
                            "name": "PXEBootMenu",
                            "csv-format": True,
                            "data": "0,17,Raspberry Pi Boot",
                            "space": "vendor-encapsulated-options-space",
                        },
                        # {
                        #     "name": "PXEDiscoveryControl",
                        #     "data": "3",
                        #     "space": "vendor-encapsulated-options-space",
                        # },
                        # {
                        #     "name": "PXEMenuPrompt",
                        #     "csv-format": True,
                        #     "data": "0,PXE",
                        #     "space": "vendor-encapsulated-options-space",
                        # },
                    ],
                },
            ],
            "subnet4": [
                {
                    "subnet": str(self.ipv4_network),
                    "next-server": str(self.ipv4_address),  # XXX per-host?
                    "match-client-id": False,
                    "option-data": [
                        {
                            "name": "routers",
                            "data": str(self.ipv4_address),
                        },
                    ],
                    "reservations": till_reservations,
                },
            ],
            "loggers": [
                {
                    "name": "kea-dhcp4",
                    "output_options": [
                        {
                            "output": "stdout",
                            "pattern": "%-5p %m\n",
                        },
                    ],
                    "severity": "INFO",
                    "debuglevel": 0,
                },
            ],
        }

        return {
            "Dhcp4": dhcp4,
        }

    def fileops(self, tills: List[Host]) -> Iterable[FileOperation]:
        ctx = {
            'script_name': sys.argv[0],
            'interface': self.interface,
            'upstream_interface': self.upstream_interface,
            'ipv4_interface': self.ipv4_interface,
            'ipv4_network': self.ipv4_network,
            'firewall_accept': self.firewall_accept,
        }

        if self.network_file:
            yield WriteTemplateFile(
                network_template, ctx, self.network_file)

        if self.nftables_file:
            yield WriteTemplateFile(
                nftables_template, ctx, self.nftables_file)

        if self.kea_dhcp4_file:
            yield WriteJsonFile(
                self.kea_dhcp4_config(tills), self.kea_dhcp4_file)


def run() -> None:
    parser = argparse.ArgumentParser("Set up networked boot for quicktill")
    parser.add_argument("--config-file", "-c", help="config file location",
                        type=Path, default="/etc/till-boot/config.toml")
    parser.add_argument("--verbose", "-v", help="output more information "
                        "about operation", action="store_true")
    parser.add_argument("--dry-run", "-n",
                        help="don't write any files",
                        action="store_true")
    args = parser.parse_args()

    if args.verbose:
        loglevel = logging.INFO
    else:
        loglevel = logging.WARNING

    logging.basicConfig(level=loglevel)

    # Read the configuration
    with args.config_file.open("rb") as f:
        config = tomllib.load(f)

    network = None
    if "network" in config:
        network = Network(config['network'])

    defaults = config.get("defaults", {})

    # Process drivers; if no drivers configured, create one
    # automatically and import the old-style configuration
    driver_config = config.get("driver", {})
    if driver_config:
        drivers = {
            name: _driver.drivers[config.get("class", name)](name, config)
            for name, config in driver_config.items()}
    else:
        log.info("old-style configuration with no drivers found")
        drivers = {"till-boot": till_boot("till-boot", config)}
        defaults['driver'] = "till-boot"

    roles = config.get("role", {})

    tills = []

    # Process the configuration for each till
    for till, till_settings in config.get("tills", {}).items():
        settings = ChainMap(till_settings, defaults)

        # At this point we can look at "role" or "roles" to figure
        # out a list of roles to load settings from, and start again
        if "role" in settings and "roles" in settings:
            log.error(
                "till %s: you can't specify both 'role' and 'roles'", till)
            continue
        if "role" in settings:
            role_names = [settings["role"]]
        elif "roles" in settings:
            role_names = settings["roles"]
        else:
            role_names = []

        if any(not isinstance(role_name, str) for role_name in role_names):
            log.error(
                "till %s: role names must be strings", till)
            continue
        if any(role_name not in roles for role_name in role_names):
            log.error(
                "till %s: role does not exist", till)
            continue

        role_settings = [roles[role_name]
                         for role_name in reversed(role_names)]

        settings = ChainMap(till_settings, *role_settings, defaults)

        # Now we should know the driver to use for this till
        driver_name = settings.get("driver")
        if not driver_name:
            log.critical("till %s: driver not specified", till)
            fail()
        driver = drivers.get(driver_name)
        if not driver:
            log.critical("till %s: driver %s does not exist",
                         till, driver_name)
            fail()
        log.info("till %s: using driver %s", till, driver_name)

        tills.append(driver.configure(till, settings))

    # Configure the network if present
    if network:
        network.allocate_addresses(tills)

    # Write host boot and configuration files
    for till in tills:
        till.apply_fileops(args.dry_run)

    # Write driver files
    for driver in drivers.values():
        for op in driver.fileops():
            op.apply(driver.log, args.dry_run)

    # Write network configuration files
    if network:
        for op in network.fileops(tills):
            op.apply(network.log, args.dry_run)


if __name__ == "__main__":
    run()
