#!/usr/bin/env python3

import sys
import os
import argparse
import yaml
import json
from pathlib import Path
import os.path
import shutil
import logging

try:
    import tomllib
except ModuleNotFoundError:
    import tomli as tomllib

log = logging.getLogger("till-boot-config")


def path_or_fail(config, cmdline, name):
    path = cmdline or config.get(name, None)
    if not path:
        log.critical("%s not specified", name)
        sys.exit(1)
    return Path(path)


def path_or_none(path):
    return Path(path) if path else None


class _platform:
    required_settings = [
        "name",  # inserted automatically
        "configurl",
        "configname",
        "dbname",
        "dbhost",
        "dbuser",
        "install",
        "fontsize",
        "repos",
    ]

    def __init__(self, info, version, mount_path, boot_path,
                 nfs_server, http_server):
        self.info = info
        self.version = version
        self.mount_path = mount_path
        self.boot_path = boot_path
        self.architecture = info['architecture']
        self.nfs_server = nfs_server
        self.http_server = http_server

    def get_append(self, settings):
        append = list(self.info['append'])
        append += [
            "netboot=nfs",
            f"nfsroot={self.nfs_server}:{self.mount_path}",
            f"till-boot-version={self.version}",
            f"till-boot-config={self.http_server}{settings['name']}.yaml",
            f"till-boot-config-json={self.http_server}{settings['name']}.json",
        ]
        return append

    def check_settings(self, settings):
        for s in self.required_settings:
            if s not in settings:
                return s

    def __str__(self):
        return f"{self.description}: {self.architecture} {self.version}"


class pc(_platform):
    description = "PC"

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.kernel = None
        self.initrd = None
        # Find our kernel and initrd files
        bpath = self.boot_path / "boot"
        possible_kernels = list(bpath.glob("vmlinuz-*"))
        if len(possible_kernels) == 1:
            self.kernel = possible_kernels[0]
        else:
            log.warning("%s: possible_kernels %s", self, possible_kernels)
        possible_initrds = list(bpath.glob("initrd.img-*"))
        if len(possible_initrds) == 1:
            self.initrd = possible_initrds[0]
        else:
            log.warning("%s: possible_initrds %s", self, possible_initrds)
        self.installed = False

    def boot_files_ok(self):
        if not self.kernel or not self.kernel.is_file():
            log.warning("%s: missing kernel", self)
            return False
        if not self.initrd or not self.initrd.is_file():
            log.warning("%s: missing initrd", self)
            return False
        return True

    def install(self, tftp_dir, http_dir, settings, latest, default_append):
        till = settings['name']

        if latest:
            kfile = f"vmlinuz-pc-{self.architecture}"
            ifile = f"initrd-pc-{self.architecture}.img"
        else:
            kfile = f"vmlinuz-pc-{self.architecture}-{self.version}"
            ifile = f"initrd-pc-{self.architecture}-{self.version}.img"

        # Copy the kernel and initrd into place if this has not
        # already been done
        if not self.installed:
            shutil.copyfile(self.kernel, http_dir / kfile)
            shutil.copyfile(self.initrd, http_dir / ifile)
            self.installed = True

        append = self.get_append(settings)
        # Including the initrd filename on the kernel command line is
        # necessary for EFI systems and harmless on others.
        append.append(f"initrd={ifile}")
        append += default_append
        append += settings.get("append", [])

        cf = tftp_dir / f"{till}.ipxe"

        with open(cf, 'w') as f:
            f.write("#!ipxe\n")
            f.write(
                f"# This file was auto-generated by {sys.argv[0]} for {till}; "
                "do not edit\n\n")
            f.write(f"echo Booting {till}\n")
            f.write(f"kernel {kfile} {' '.join(append)} || chain ipxe.pxe\n")
            f.write(f"initrd {ifile}\n")
            f.write("boot\n")


class rpi(_platform):
    description = "Raspberry PI"
    required_boot_files = [
        "bootcode.bin",
        "start.elf",
        "fixup.dat",
        "start4.elf",
        "fixup4.dat",
        "start4x.elf",
        "fixup4x.dat",
    ]
    initrd_suffixes = {
        'kernel.img': '+',
        'kernel7.img': '-v7+',
        'kernel7l.img': '-v7l+',
        'kernel8.img': '-v8+',
    }
    armhf_kernels = {
        'pi0': 'kernel.img',
        'pi1': 'kernel.img',
        'pi2': 'kernel7.img',
        'pi3': 'kernel7.img',
        'pi4': 'kernel7l.img',
    }

    required_settings = _platform.required_settings + ["serial"]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.bpath = self.boot_path / "boot"
        possible_initrds = list(self.bpath.glob("initrd.img-*"))
        prefix = os.path.commonprefix([x.name for x in possible_initrds])
        self.initrds = {}  # kernel name -> initrd path
        for kernel_name, suffix in self.initrd_suffixes.items():
            kernel = self.bpath / kernel_name
            if not kernel.is_file():
                continue
            initrd = None
            for i in possible_initrds:
                if not i.is_file():
                    continue
                if i.name[len(prefix):] == suffix:
                    initrd = i
                    break
            if initrd:
                self.initrds[kernel_name] = initrd

    def get_append(self, settings):
        append = super().get_append(settings)
        if 'ntp-server' in settings:
            append.append(f"ntp-server={settings['ntp-server']}")
        return append

    def boot_files_ok(self):
        for f in self.required_boot_files:
            path = self.bpath / f
            if not path.is_file():
                return False
        if self.architecture == "armhf":
            for k in ("kernel.img", "kernel7.img", "kernel7l.img"):
                if k not in self.initrds:
                    return False
        elif self.architecture == "arm64":
            if "kernel8.img" not in self.initrds:
                return False
        return True

    def install(self, tftp_dir, http_dir, settings, latest, default_append):
        till = settings['name']

        if 'ntp-server' not in settings:
            log.warning("%s: ntp-server not specified, time will "
                        "not be set in initrd", till)

        serial = settings['serial']
        serial_dir = tftp_dir / serial

        override_firmware = path_or_none(settings.get("override-firmware"))

        # Copy the firmware and kernel into place
        shutil.rmtree(serial_dir, ignore_errors=True)
        if override_firmware:
            shutil.copytree(override_firmware, serial_dir)
            # Use the kernels and initrds from the image
            for kernel, initrd in self.initrds.items():
                shutil.copy(self.bpath / kernel, serial_dir)
                shutil.copy(initrd, serial_dir)
        else:
            shutil.copytree(self.bpath, serial_dir)

        # Kernel command line
        append = self.get_append(settings)
        append += default_append
        append += settings.get("append", [])
        with open(serial_dir / "cmdline.txt", 'w') as f:
            f.write(' '.join(append))
            f.write('\n')

        # Config file
        with open(serial_dir / "config.txt", 'w') as f:
            f.write(f"# This file was auto-generated by {sys.argv[0]} "
                    f"for {till}; do not edit\n\n")

            if self.architecture == 'armhf':
                for model, kernel in self.armhf_kernels.items():
                    f.write(f"[{model}]\n")
                    f.write(f"initramfs {self.initrds[kernel].name} "
                            f"followkernel\n\n")
            if self.architecture == 'arm64':
                f.write("arm_64bit=1\n")
                f.write(f"initramfs {self.initrds['kernel8.img'].name} "
                        f"followkernel\n\n")
            for model in self.armhf_kernels.keys():
                mcfg = self.info.get(f"config-{model}", []) \
                    + settings.get(f"config-{model}", [])
                if mcfg:
                    f.write(f"[{model}]\n")
                    for ci in mcfg:
                        f.write(f"{ci}\n")
                    f.write("\n")
            f.write("[all]\n")
            for ci in self.info.get("config", []) + settings.get("config", []):
                f.write(f"{ci}\n")
            f.write("\n# end\n\n")


platforms = {
    'pc': pc,
    'rpi': rpi,
}


def run():
    parser = argparse.ArgumentParser("Set up networked boot for quicktill")
    parser.add_argument("--config-file", "-c", help="config file location",
                        default="/etc/till-boot/config.toml")
    parser.add_argument("--nfs-dir", help="override nfs root location")
    parser.add_argument("--tftp-dir", help="override tftp dir location")
    parser.add_argument("--boot-dir",
                        help="override kernel+initrd dir location")
    parser.add_argument("--loaders-dir", help="override loaders loction")
    parser.add_argument("--http-dir", help="override http dir location")
    parser.add_argument("--verbose", "-v", help="output more information "
                        "about operation", action="store_true")
    parser.add_argument("--dry-run", "-n",
                        help="don't write to tftp-dir or http-dir",
                        action="store_true")
    args = parser.parse_args()

    if args.verbose:
        loglevel = logging.INFO
    else:
        loglevel = logging.WARNING

    logging.basicConfig(level=loglevel)

    # Read the configuration
    config = None
    cf = args.config_file
    try:
        with open(cf, "rb") as f:
            config = tomllib.load(f)
    except FileNotFoundError:
        # Support legacy yaml config files for now
        if cf.lower().endswith(".toml"):
            cf = cf[:-5]
            with open(cf) as f:
                config = yaml.safe_load(f)

    nfs_dir = path_or_fail(config, args.nfs_dir, "nfs-dir")
    tftp_dir = path_or_fail(config, args.tftp_dir, "tftp-dir")
    boot_dir = path_or_fail(config, args.boot_dir, "boot-dir")
    http_dir = path_or_fail(config, args.http_dir, "http-dir")
    loaders_dir = path_or_none(args.loaders_dir or config.get(
        "loaders-dir"))
    if not loaders_dir:
        loaders_dir = nfs_dir / 'loaders'
    if not loaders_dir.is_dir():
        log.critical("loaders dir %s doesn't exist", loaders_dir)
        sys.exit(1)

    loaders = loaders_dir.glob("*")

    default_append = config.get("default-append", [])

    defaults = config.get("defaults", {})

    # Initial checks: nfs_dir, tftp_dir and http_dir must exist and be
    # directories
    if not nfs_dir.is_dir():
        log.critical("nfs root dir %s doesn't exist", nfs_dir)
        sys.exit(1)
    if not tftp_dir.is_dir():
        log.critical("tftp dir %s doesn't exist", tftp_dir)
        sys.exit(1)
    if not http_dir.is_dir():
        log.critical("http dir %s doesn't exist", http_dir)
        sys.exit(1)

    if not nfs_dir.is_absolute():
        log.warning("nfs dir %s is relative", nfs_dir)
    if not tftp_dir.is_absolute():
        log.warning("tftp dir %s is relative", tftp_dir)
    if not http_dir.is_absolute():
        log.warning("http dir %s is relative", http_dir)

    if not boot_dir.is_dir():
        log.critical("boot files directory %s doesn't exist", boot_dir)
        sys.exit(1)

    # Not currently used, but will be used in the future to generate a
    # dhcpd config file fragment
    tftp_server = config.get("tftp-server")
    if not tftp_server:
        log.critical("tftp-server is not specified")
        sys.exit(1)

    http_server = config.get("http-server")
    if not http_server:
        log.critical("http-server is not specified")
        sys.exit(1)
    if http_server[-1] != '/':
        http_server = http_server + '/'

    nfs_server = config.get("nfs-server")
    if not nfs_server:
        log.critical("nfs-server is not specified")
        sys.exit(1)

    # Build a catalog of till boot files available on this machine
    # (platform, arch, version) => platform class instance
    catalog = {}
    platform_dirs = nfs_dir.glob("*")
    for platform_dir in platform_dirs:
        if platform_dir == loaders_dir:
            continue
        if not platform_dir.is_dir():
            continue
        if platform_dir.name not in platforms:
            log.warning("unknown platform %s in nfs dir", platform_dir.name)
            continue
        for arch_dir in platform_dir.glob("*"):
            if not arch_dir.is_dir():
                continue
            for version_dir in arch_dir.glob("*"):
                if not version_dir.is_dir():
                    continue
                platform = platform_dir.name
                arch = arch_dir.name
                version = version_dir.name
                bpath = boot_dir / platform / arch / version
                # Check that the image info file exists
                info_file = version_dir / "image-info.yaml"
                if not info_file.is_file():
                    log.warning("%s is not a file", info_file)
                    continue
                # Parse the info file
                with open(info_file) as f:
                    info = yaml.safe_load(f)
                # Check that platform and arch match
                if info.get('platform') != platform:
                    log.warning("platform in info file %s does not match path",
                                info_file)
                    continue
                if info.get('architecture') != arch:
                    log.warning("arch in info file %s does not match path",
                                info_file)
                    continue
                platform_class = platforms.get(platform)
                if not platform_class:
                    log.warning("unsupported platform %s", platform)
                    continue
                image = platform_class(info, version, version_dir, bpath,
                                       nfs_server, http_server)
                # Check the boot files are ok for the platform
                if not image.boot_files_ok():
                    log.warning("missing boot files for %s", image)
                    continue
                # Add to the catalog
                log.info("available: %s %s %s", platform, arch, version)
                catalog[(platform, arch, version)] = image

    # Build a dictionary of (platform, arch) -> latest version
    latest = {}
    for platform, arch, version in catalog.keys():
        if version > latest.get((platform, arch), ""):
            latest[(platform, arch)] = version

    # Process the configuration for each till
    for till, till_settings in config.get("tills", {}).items():
        log.info("Working on %s", till)
        settings = defaults.copy()
        settings.update(till_settings)

        # We should now know the platform, and we can do this again
        # including the platform defaults
        platform = settings.get("platform")
        if not platform:
            log.error("till %s: no platform specified", till)
            continue

        settings = defaults.copy()
        platform_defaults = config.get(f"defaults-{platform}")
        if platform_defaults:
            settings.update(platform_defaults)
        settings.update(till_settings)
        settings['name'] = till

        arch = settings.get("architecture")
        version = settings.get("version")
        if isinstance(version, int):
            version = str(version)
            settings["version"] = version
        if not arch or not version:
            log.error("till %s: incomplete specification of arch/version",
                      till)
            continue
        using_latest = False
        if version == "latest":
            version = latest.get((platform, arch))
            using_latest = True
            settings["version"] = version

        image = catalog.get((platform, arch, version))

        if not image:
            log.error("till %s: requested platform/arch/version not available",
                      till)
            continue

        missing_setting = image.check_settings(settings)
        if missing_setting:
            log.error("till %s: %s missing", till, missing_setting)
            continue

        image.install(tftp_dir, http_dir, settings, using_latest,
                      default_append)

        hf = http_dir / f"{till}.yaml"
        with hf.open('w') as f:
            f.write("%YAML 1.1\n")
            f.write("---\n")
            f.write(f"# This file was auto-generated by {sys.argv[0]} "
                    f"for {till}; do not edit\n")
            yaml.dump(settings, f)

        jf = http_dir / f"{till}.json"
        with jf.open('w') as f:
            json.dump(settings, f, indent=2)

    # Make sure the loaders are copied into the tftp dir
    for loader in loaders:
        dest = tftp_dir / loader.name
        if dest.exists():
            dest.unlink()
        shutil.copyfile(loader, dest)


if __name__ == "__main__":
    run()
