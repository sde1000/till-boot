#!/usr/bin/env python3

import sys
import os
import argparse
import yaml
from pathlib import Path
import shutil
import socket
import logging

log = logging.getLogger("till-boot-setup")

def run():
    parser = argparse.ArgumentParser("Set up networked boot for quicktill")
    parser.add_argument("--config-file", "-c", help="config file location",
                        default="/etc/till-boot/config")
    parser.add_argument("--nfs-dir", help="override nfs root location")
    parser.add_argument("--tftp-dir", help="override tftp dir location")
    parser.add_argument("--boot-dir",
                        help="override kernel+initrd dir location")
    parser.add_argument("distribution")
    parser.add_argument("arch")
    parser.add_argument("version")
    args = parser.parse_args()

    # Read the configuration
    with open(args.config_file) as f:
        config = yaml.load(f)

    nfs_dir = Path(args.nfs_dir or config["nfs-dir"])
    tftp_dir = Path(args.tftp_dir or config["tftp-dir"])
    boot_dir = Path(args.boot_dir or config["boot-dir"])
    config_dir = tftp_dir

    nfs_root_dir = nfs_dir / args.distribution / args.arch / args.version
    default_append = config.get("default-append", [])

    # Initial checks: nfs_dir and tftp_dir should exist and be directories
    if not nfs_dir.is_dir():
        log.critical("nfs root dir %s doesn't exist", nfs_dir)
        sys.exit(1)
    if not tftp_dir.is_dir():
        log.critical("tftp dir %s doesn't exist", tftp_dir)
        sys.exit(1)

    if not nfs_dir.is_absolute():
        log.warning("nfs dir %s is relative", nfs_dir)
    if not tftp_dir.is_absolute():
        log.warning("tftp dir %s is relative", tftp_dir)

    # Create the config dir if it doesn't exist
    config_dir.mkdir(mode=0o755, exist_ok=True)

    # Make sure the loaders are copied into the tftp dir
    loaders_dir = nfs_dir / 'loaders' / args.arch
    if not loaders_dir.is_dir():
        log.critical("loaders dir %s doesn't exist", loaders_dir)
        sys.exit(1)
    loaders = loaders_dir.glob("*")
    for l in loaders:
        dest = tftp_dir / l.name
        if dest.exists():
            dest.unlink()
        # Passing a PathLike to shutil and os.path functions doesn't
        # work until python3.6 - unfortunately Ubuntu 16.04 only has
        # python3.5.
        shutil.copyfile(str(l), str(dest))

    boot_dir = boot_dir / args.distribution / args.arch / args.version
    if not boot_dir.is_dir():
        log.critical("boot files directory %s doesn't exist", boot_dir)
        sys.exit(1)
    def copy_boot_file(name):
        file_src = boot_dir / name
        file_dest = tftp_dir / name
        if file_dest.exists():
            file_dest.unlink()
        # Can pass file_src and file_dest directly once using python3.6
        shutil.copyfile(str(file_src), str(file_dest))
    copy_boot_file("vmlinuz")
    copy_boot_file("initrd.img")

    # Write out a config file for each till.  Config files are named
    # for the till with a ".ipxe" extension and should be used as the
    # "filename" in the DHCP server's response.
    for till, settings in config.get("tills", {}).items():
        cf = config_dir / "{}.ipxe".format(till)
        append = [
            "initrd=initrd.img",
            "netboot=nfs",
            "nfsroot={}:{}".format(config["nfs-server"], nfs_root_dir),
            "boot=casper"
        ]
        append += default_append
        append += settings.get("append", [])
        # Shorthand, because I keep getting it wrong!
        if "configname" in settings:
            append.append("configname={}".format(settings["configname"]))
        #ipaddrs = []
        #dns_names = settings.get("dns-names", [])
        #ip4addrs = settings.get("ipv4-addrs", [])
        #ip4addrs += [socket.gethostbyname(x) for x in dns_names]

        # From python3.6 onward this can be written open(cf, 'w')
        with cf.open('w') as f:
            f.write("#!ipxe\n")
            f.write("# This file was auto-generated by {} for {}; "
                    "do not edit\n\n".format(sys.argv[0], till))
            f.write("echo Booting {}\n".format(till))
            f.write("kernel vmlinuz {} || chain ipxe.pxe\n".format(
                " ".join(append)))
            f.write("initrd initrd.img\n")
            #f.write("imgstat\n")
            #f.write("sleep 10\n")
            f.write("boot\n")

if __name__ == "__main__":
    run()
